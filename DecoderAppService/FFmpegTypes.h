//Copyright (c) Microsoft Corporation. All rights reserved.

#pragma once

#include "pch.h"

////////////////////////////////////////////////////
// generated by build, has FFMPEG_CODEC_<Name>
// and FFMPEG_<FORMAT>_INPUT_<TYPE> types
// Has avformat.h (AVPacket/AVFrame).
#include "FFmpegBuildCodecs.g.h" 
////////////////////////////////////////////////////

using namespace Windows::Storage::Streams;

/**
* Checks if an array has a given value.
*
* @param arr   ([in]  anything[])  the array.
* @param has   ([in]  anything)    the value to check.
* @param found ([out] int*)        set to TRUE if found, else FALSE.
*/
#define ARRAYFIND(arr, has, found) \
	do { \
		*(found) = -1; \
		for (int i = 0; i < ARRAYSIZE(arr); i++) { \
			if (arr[i] == (has)) *(found) = i; \
		} \
	} while (0)

/**
 * Translates an element from one array to an element from another array.
 * If ele1 is at position n in arr1, ele2 will be set to element n of
 * arr2. If a translation is not possible, ele2 will be null.
 *
 * @param arr1  ([in]  TOne[])  the source array.
 * @param arr2  ([in]  TTwo[])  the destination array.
 * @param ele1  ([in]  TOne)    the source element.
 * @param ele2  ([out] TTwo)    the resulting element.
 */
#define ARRAYTRANSLATE(arr1, arr2, ele1, ele2) \
	do { \
		int _pos; \
		ARRAYFIND(arr1, ele1, &_pos); \
		if(_pos >= 0) (ele2) = (arr2)[_pos]; \
	} while (0)

namespace FFmpegPack {

	///////////////////////////////////////////////////////////
	//   Input and output type metadata
	///////////////////////////////////////////////////////////

	#define FFMPEG_INPUT_VIDEO_COUNT ARRAYSIZE(FFMPEG_MFTYPES_INPUT_VIDEO)
	#define FFMPEG_INPUT_AUDIO_COUNT ARRAYSIZE(FFMPEG_MFTYPES_INPUT_AUDIO)

	#define FFMPEG_INPUT_COUNT \
		(FFMPEG_INPUT_VIDEO_COUNT + FFMPEG_INPUT_AUDIO_COUNT)

	const int FFMPEG_INPUT_BUFFER_SIZE = 32768;
	const int FFMPEG_OUTPUT_BUFFER_SIZE = 32768;

	/**
	 * Bits per pixel of the output format. Only 12bpp supported right now.
	 * (i.e NV12 specifically). Could extend this to support several different.
	 */
	const float FFMPEG_OUTPUT_BITS_PER_PIXEL = 12;


	///////////////////////////////////////////////////////////
	//   Interlaced video
	//   https://msdn.microsoft.com/en-us/library/windows/desktop/aa367729(v=vs.85).aspx
	//   - this is a best guess matching tbh
	///////////////////////////////////////////////////////////
	
	const AVFieldOrder FFMPEG_AVTYPES_INTERLACE[] = {
		AV_FIELD_UNKNOWN,
		AV_FIELD_PROGRESSIVE,
		AV_FIELD_TT,
		AV_FIELD_BB,
		AV_FIELD_TB,
		AV_FIELD_BT
	};

	const MFVideoInterlaceMode FFMPEG_MFTYPES_INTERLACE[] = {
		MFVideoInterlace_Unknown,
		MFVideoInterlace_Progressive,
		MFVideoInterlace_FieldInterleavedUpperFirst,
		MFVideoInterlace_FieldInterleavedLowerFirst,
		MFVideoInterlace_FieldSingleUpper,
		MFVideoInterlace_FieldSingleLower
	};

	///////////////////////////////////////////////////////////
	//   Video Transfer Functions
	//   https://msdn.microsoft.com/en-us/library/windows/desktop/ms705629(v=vs.85).aspx
	//   - this is a best guess matching tbh
	///////////////////////////////////////////////////////////


	const MFVideoTransferFunction FFMPEG_MFTYPES_VIDEO_TRANSFER[] = {
		MFVideoTransFunc_Unknown,
		MFVideoTransFunc_10,
		//MFVideoTransFunc_18,
		//MFVideoTransFunc_20,
		MFVideoTransFunc_22,
		MFVideoTransFunc_709,
		MFVideoTransFunc_240M,
		MFVideoTransFunc_sRGB,
		MFVideoTransFunc_28,
		MFVideoTransFunc_Log_100,
		MFVideoTransFunc_Log_316,
		//MFVideoTransFunc_709_sym,
		MFVideoTransFunc_2020_const,
		MFVideoTransFunc_2020,
		//MFVideoTransFunc_26,
		MFVideoTransFunc_2084,
		MFVideoTransFunc_HLG,
	};
	
	const AVColorTransferCharacteristic FFMPEG_AVTYPES_VIDEO_TRANSFER[] = {
		AVCOL_TRC_UNSPECIFIED,  //MFVideoTransFunc_Unknown,
		AVCOL_TRC_LINEAR,       //MFVideoTransFunc_10,
						        //MFVideoTransFunc_18
						        //MFVideoTransFunc_20
		AVCOL_TRC_GAMMA22,      //MFVideoTransFunc_22,
		AVCOL_TRC_BT709,        //MFVideoTransFunc_709,
		AVCOL_TRC_SMPTE240M,    //MFVideoTransFunc_240M,
		AVCOL_TRC_IEC61966_2_4, //MFVideoTransFunc_sRGB,
		AVCOL_TRC_GAMMA28,      //MFVideoTransFunc_28,
		AVCOL_TRC_LOG,          //MFVideoTransFunc_Log_100,
		AVCOL_TRC_LOG_SQRT,     //MFVideoTransFunc_Log_316,
							    //MFVideoTransFunc_709_sym,
		AVCOL_TRC_BT2020_12,    //MFVideoTransFunc_2020_const,
		AVCOL_TRC_BT2020_12,    //MFVideoTransFunc_2020,
							    //MFVideoTransFunc_26,
		AVCOL_TRC_SMPTEST2084,  //MFVideoTransFunc_2084,
		AVCOL_TRC_ARIB_STD_B67, //MFVideoTransFunc_HLG,
	};

	//AVCOL_TRC_BT1361_ECG ITU - R BT1361 Extended Colour Gamut.
	//AVCOL_TRC_IEC61966_2_1 IEC 61966 - 2 - 1 (sRGB or sYCC) not used?
	//AVCOL_TRC_BT2020_10 ITU - R BT2020 for 10 - bit system.
	//AVCOL_TRC_BT2020_12 ITU - R BT2020 for 12 - bit system.
	//AVCOL_TRC_SMPTE2084 SMPTE ST 2084 for 10 - , 12 - , 14 - and 16 - bit systems.
	//AVCOL_TRC_SMPTE428 SMPTE ST 428 - 1.
	//AVCOL_TRC_SMPTEST428_1 
	//AVCOL_TRC_NB Not part of ABI.
	

	///////////////////////////////////////////////////////////
	//   Video Chroma Subsampling/Location
	//  https://msdn.microsoft.com/en-us/library/windows/desktop/ms698989(v=vs.85).aspx
	//   - this is a best guess matching tbh
	///////////////////////////////////////////////////////////

	const MFVideoChromaSubsampling FFMPEG_MFTYPES_VIDEO_CHROMA[] = {
		MFVideoChromaSubsampling_Unknown,
		//MFVideoChromaSubsampling_ProgressiveChroma                = 0x8,
		//MFVideoChromaSubsampling_Horizontally_Cosited             = 0x4,
		//MFVideoChromaSubsampling_Vertically_Cosited               = 0x2,
		//MFVideoChromaSubsampling_Vertically_AlignedChromaPlanes   = 0x1,
		MFVideoChromaSubsampling_MPEG2,
		MFVideoChromaSubsampling_MPEG1,
		MFVideoChromaSubsampling_DV_PAL,
		MFVideoChromaSubsampling_Cosited,
	};

	const AVChromaLocation FFMPEG_AVTYPES_VIDEO_CHROMA[] = {
		AVCHROMA_LOC_UNSPECIFIED,
		//MFVideoChromaSubsampling_ProgressiveChroma                = 0x8,
		//MFVideoChromaSubsampling_Horizontally_Cosited             = 0x4,
		//MFVideoChromaSubsampling_Vertically_Cosited               = 0x2,
		//MFVideoChromaSubsampling_Vertically_AlignedChromaPlanes   = 0x1,
		AVCHROMA_LOC_LEFT, //MFVideoChromaSubsampling_MPEG2
		AVCHROMA_LOC_CENTER, //MFVideoChromaSubsampling_MPEG1
		AVCHROMA_LOC_BOTTOMLEFT, //MFVideoChromaSubsampling_DV_PAL,
		AVCHROMA_LOC_TOPLEFT, //MFVideoChromaSubsampling_Cosited - (DV 4:1:1), mpeg2 4:2:2
	};


	///////////////////////////////////////////////////////////
	//   Video Color Primaries
	//   https://msdn.microsoft.com/en-us/library/windows/desktop/ms701628(v=vs.85).aspx
	//   - this is a best guess matching tbh
	///////////////////////////////////////////////////////////

	const MFVideoPrimaries FFMPEG_MFTYPES_VIDEO_PRIMARIES[] = {
		MFVideoPrimaries_Unknown,
		//MFVideoPrimaries_reserved        = 1,
		MFVideoPrimaries_BT709,
		MFVideoPrimaries_BT470_2_SysM,
		MFVideoPrimaries_BT470_2_SysBG,
		MFVideoPrimaries_SMPTE170M,
		MFVideoPrimaries_SMPTE240M,
		//MFVideoPrimaries_EBU3213         = 7,
		//MFVideoPrimaries_SMPTE_C         = 8,
		MFVideoPrimaries_BT2020,
		MFVideoPrimaries_XYZ,
		//MFVideoPrimaries_DCI_P3,
		//MFVideoPrimaries_ACES            = 12,
	};

	const AVColorPrimaries FFMPEG_AVTYPES_VIDEO_PRIMARIES[] = {
		AVCOL_PRI_UNSPECIFIED,
		//MFVideoPrimaries_reserved        = 1,
		AVCOL_PRI_BT709, //MFVideoPrimaries_BT709           = 2,
		AVCOL_PRI_BT470M, //MFVideoPrimaries_BT470_2_SysM    = 3,
		AVCOL_PRI_BT470BG, //MFVideoPrimaries_BT470_2_SysBG   = 4,
		AVCOL_PRI_SMPTE170M, //MFVideoPrimaries_SMPTE170M       = 5,
		AVCOL_PRI_SMPTE240M, //MFVideoPrimaries_SMPTE240M       = 6,
		//MFVideoPrimaries_EBU3213         = 7,  - same as BT470BG?
		//MFVideoPrimaries_SMPTE_C         = 8,  - same as SMPTE170M?
		AVCOL_PRI_BT2020, //MFVideoPrimaries_BT2020          = 9,
		AVCOL_PRI_SMPTEST428_1, //MFVideoPrimaries_XYZ             = 10,
		//AVCOL_PRI_SMPTE431, //MFVideoPrimaries_DCI_P3,  - not supported at the moment
		//MFVideoPrimaries_ACES            = 12, 2065-4
	};


	///////////////////////////////////////////////////////////
	//   YUV Color Space Types
	//   https://msdn.microsoft.com/en-us/library/windows/desktop/ms694036(v=vs.85).aspx
	//   - this is a best guess matching tbh
	///////////////////////////////////////////////////////////
	const MFVideoTransferMatrix FFMPEG_MFTYPES_VIDEO_COLOR_SPACE[] = {
		MFVideoTransferMatrix_Unknown,
		MFVideoTransferMatrix_BT709,
		MFVideoTransferMatrix_BT601,
		MFVideoTransferMatrix_SMPTE240M,
	};

	const AVColorSpace FFMPEG_AVTYPES_VIDEO_COLOR_SPACE[] = {
		AVCOL_SPC_UNSPECIFIED,
		AVCOL_SPC_BT709, //MFVideoTransferMatrix_BT709        = 1,
		AVCOL_SPC_BT470BG, //MFVideoTransferMatrix_BT601 = 2, - could also be AVCOL_SPC_SMPTE170M
		AVCOL_SPC_SMPTE240M, //MFVideoTransferMatrix_SMPTE240M    = 3,
	};



	/** Conversion utilities between MF and FFmpeg. */
	class FFmpegTypes {
	public:
		static HRESULT PacketFromSample(_Out_ AVPacket *pPacket, _In_ IMFSample *pSample);
		static HRESULT SampleFromBuffer(_Out_ IMFSample *pSample, _In_ IBuffer^ hBuffer);
		static HRESULT SampleFromArray(_Out_ IMFSample *pSample, _In_ Platform::Array<BYTE> ^hArray);

		static HRESULT CodecParamsFromMediaType(_Out_ AVCodecParameters *pCodecParams, _In_ IMFMediaType *pMediaTypeIn, _In_ IMFMediaType *pMediaTypeOut);
		static HRESULT CopySample(_In_ CComPtr<IMFSample> spSourceSample, _Out_ CComPtr<IMFSample> spDestSample);
	
		static LONGLONG TimeToAVTime(LONGLONG time, AVRational timeBase);

	private:
		static HRESULT FFmpegTypes::_AudioCodecParams(_Inout_ AVCodecParameters *pCodecParams, _In_ IMFMediaType *pMediaTypeIn, _In_ IMFMediaType *pMediaTypeOut);
		static HRESULT FFmpegTypes::_VideoCodecParams(_Inout_ AVCodecParameters *pCodecParams, _In_ IMFMediaType *pMediaTypeIn, _In_ IMFMediaType *pMediaTypeOut);
	};
};
